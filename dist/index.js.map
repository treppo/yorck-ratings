{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/js-csp/src/csp.core.js",
    "node_modules/js-csp/src/csp.js",
    "node_modules/js-csp/src/csp.operations.js",
    "node_modules/js-csp/src/csp.pipeline.js",
    "node_modules/js-csp/src/impl/buffers.js",
    "node_modules/js-csp/src/impl/channels.js",
    "node_modules/js-csp/src/impl/dispatch.js",
    "node_modules/js-csp/src/impl/process.js",
    "node_modules/js-csp/src/impl/select.js",
    "node_modules/js-csp/src/impl/timers.js",
    "src/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\n\nvar buffers = require(\"./impl/buffers\");\nvar channels = require(\"./impl/channels\");\nvar select = require(\"./impl/select\");\nvar process = require(\"./impl/process\");\nvar timers = require(\"./impl/timers\");\n\nfunction spawn(gen, creator) {\n  var ch = channels.chan(buffers.fixed(1));\n  (new process.Process(gen, function(value) {\n    if (value === channels.CLOSED) {\n      ch.close();\n    } else {\n      process.put_then_callback(ch, value, function(ok) {\n        ch.close();\n      });\n    }\n  }, creator)).run();\n  return ch;\n};\n\nfunction go(f, args) {\n  args = args || [];\n\n  var gen = f.apply(null, args);\n  return spawn(gen, f);\n};\n\nfunction chan(bufferOrNumber, xform, exHandler) {\n  var buf;\n  if (bufferOrNumber === 0) {\n    bufferOrNumber = null;\n  }\n  if (typeof bufferOrNumber === \"number\") {\n    buf = buffers.fixed(bufferOrNumber);\n  } else {\n    buf = bufferOrNumber;\n  }\n  return channels.chan(buf, xform, exHandler);\n};\n\nfunction promiseChan(xform, exHandler){\n    return chan(buffers.promise(), xform, exHandler);\n};\n\n\nmodule.exports = {\n  buffers: {\n    fixed: buffers.fixed,\n    dropping: buffers.dropping,\n    sliding: buffers.sliding,\n    promise: buffers.promise\n  },\n\n  spawn: spawn,\n  go: go,\n  chan: chan,\n  promiseChan: promiseChan,\n  DEFAULT: select.DEFAULT,\n  CLOSED: channels.CLOSED,\n\n  put: process.put,\n  take: process.take,\n  sleep: process.sleep,\n  alts: process.alts,\n  putAsync: process.put_then_callback,\n  takeAsync: process.take_then_callback,\n\n  timeout: timers.timeout\n};\n",
    "\"use strict\";\n\nvar csp = require(\"./csp.core\");\nvar operations = require(\"./csp.operations\");\nvar pipeline = require('./csp.pipeline');\n\ncsp.operations = operations;\ncsp.operations.pipeline = pipeline.pipeline;\ncsp.operations.pipelineAsync = pipeline.pipelineAsync;\n\nmodule.exports = csp;\n",
    "\"use strict\";\n\nvar Box = require(\"./impl/channels\").Box;\n\nvar csp = require(\"./csp.core\"),\n    go = csp.go,\n    take = csp.take,\n    put = csp.put,\n    takeAsync = csp.takeAsync,\n    putAsync = csp.putAsync,\n    alts = csp.alts,\n    chan = csp.chan,\n    CLOSED = csp.CLOSED;\n\n\nfunction mapFrom(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(value, handler);\n    },\n    _take: function(handler) {\n      var result = ch._take({\n        is_active: function() {\n          return handler.is_active();\n        },\n        commit: function() {\n          var take_cb = handler.commit();\n          return function(value) {\n            return take_cb(value === CLOSED ? CLOSED : f(value));\n          };\n        }\n      });\n      if (result) {\n        var value = result.value;\n        return new Box(value === CLOSED ? CLOSED : f(value));\n      } else {\n        return null;\n      }\n    }\n  };\n}\n\nfunction mapInto(f, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      return ch._put(f(value), handler);\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction filterFrom(p, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        out.close();\n        break;\n      }\n      if (p(value)) {\n        yield put(out, value);\n      }\n    }\n  });\n  return out;\n}\n\nfunction filterInto(p, ch) {\n  return {\n    is_closed: function() {\n      return ch.is_closed();\n    },\n    close: function() {\n      ch.close();\n    },\n    _put: function(value, handler) {\n      if (p(value)) {\n        return ch._put(value, handler);\n      } else {\n        return new Box(!ch.is_closed());\n      }\n    },\n    _take: function(handler) {\n      return ch._take(handler);\n    }\n  };\n}\n\nfunction removeFrom(p, ch) {\n  return filterFrom(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction removeInto(p, ch) {\n  return filterInto(function(value) {\n    return !p(value);\n  }, ch);\n}\n\nfunction* mapcat(f, src, dst) {\n  while (true) {\n    var value = yield take(src);\n    if (value === CLOSED) {\n      dst.close();\n      break;\n    } else {\n      var seq = f(value);\n      var length = seq.length;\n      for (var i = 0; i < length; i++) {\n        yield put(dst, seq[i]);\n      }\n      if (dst.is_closed()) {\n        break;\n      }\n    }\n  }\n}\n\nfunction mapcatFrom(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(mapcat, [f, ch, out]);\n  return out;\n}\n\nfunction mapcatInto(f, ch, bufferOrN) {\n  var src = chan(bufferOrN);\n  go(mapcat, [f, src, ch]);\n  return src;\n}\n\nfunction pipe(src, dst, keepOpen) {\n  go(function*() {\n    while (true) {\n      var value = yield take(src);\n      if (value === CLOSED) {\n        if (!keepOpen) {\n          dst.close();\n        }\n        break;\n      }\n      if (!(yield put(dst, value))) {\n        break;\n      }\n    }\n  });\n  return dst;\n}\n\nfunction split(p, ch, trueBufferOrN, falseBufferOrN) {\n  var tch = chan(trueBufferOrN);\n  var fch = chan(falseBufferOrN);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        tch.close();\n        fch.close();\n        break;\n      }\n      yield put(p(value) ? tch : fch, value);\n    }\n  });\n  return [tch, fch];\n}\n\nfunction reduce(f, init, ch) {\n  return go(function*() {\n    var result = init;\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        return result;\n      } else {\n        result = f(result, value);\n      }\n    }\n  }, [], true);\n}\n\nfunction onto(ch, coll, keepOpen) {\n  return go(function*() {\n    var length = coll.length;\n    // FIX: Should be a generic looping interface (for...in?)\n    for (var i = 0; i < length; i++) {\n      yield put(ch, coll[i]);\n    }\n    if (!keepOpen) {\n      ch.close();\n    }\n  });\n}\n\n// TODO: Bounded?\nfunction fromColl(coll) {\n  var ch = chan(coll.length);\n  onto(ch, coll);\n  return ch;\n}\n\nfunction map(f, chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var length = chs.length;\n  // Array holding 1 round of values\n  var values = new Array(length);\n  // TODO: Not sure why we need a size-1 buffer here\n  var dchan = chan(1);\n  // How many more items this round\n  var dcount;\n  // put callbacks for each channel\n  var dcallbacks = new Array(length);\n  for (var i = 0; i < length; i ++) {\n    dcallbacks[i] = (function(i) {\n      return function(value) {\n        values[i] = value;\n        dcount --;\n        if (dcount === 0) {\n          putAsync(dchan, values.slice(0));\n        }\n      };\n    }(i));\n  }\n  go(function*() {\n    while (true) {\n      dcount = length;\n      // We could just launch n goroutines here, but for effciency we\n      // don't\n      for (var i = 0; i < length; i ++) {\n        try {\n          takeAsync(chs[i], dcallbacks[i]);\n        } catch (e) {\n          // FIX: Hmm why catching here?\n          dcount --;\n        }\n      }\n      var values = yield take(dchan);\n      for (i = 0; i < length; i ++) {\n        if (values[i] === CLOSED) {\n          out.close();\n          return;\n        }\n      }\n      yield put(out, f.apply(null, values));\n    }\n  });\n  return out;\n}\n\nfunction merge(chs, bufferOrN) {\n  var out = chan(bufferOrN);\n  var actives = chs.slice(0);\n  go(function*() {\n    while (true) {\n      if (actives.length === 0) {\n        break;\n      }\n      var r = yield alts(actives);\n      var value = r.value;\n      if (value === CLOSED) {\n        // Remove closed channel\n        var i = actives.indexOf(r.channel);\n        actives.splice(i, 1);\n        continue;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction into(coll, ch) {\n  var result = coll.slice(0);\n  return reduce(function(result, item) {\n    result.push(item);\n    return result;\n  }, result, ch);\n}\n\nfunction takeN(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    for (var i = 0; i < n; i ++) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nvar NOTHING = {};\n\nfunction unique(ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        break;\n      }\n      if (value === last) {\n        continue;\n      }\n      last = value;\n      yield put(out, value);\n    }\n    out.close();\n  });\n  return out;\n}\n\nfunction partitionBy(f, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  var part = [];\n  var last = NOTHING;\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      if (value === CLOSED) {\n        if (part.length > 0) {\n          yield put(out, part);\n        }\n        out.close();\n        break;\n      } else {\n        var newItem = f(value);\n        if (newItem === last || last === NOTHING) {\n          part.push(value);\n        } else {\n          yield put(out, part);\n          part = [value];\n        }\n        last = newItem;\n      }\n    }\n  });\n  return out;\n}\n\nfunction partition(n, ch, bufferOrN) {\n  var out = chan(bufferOrN);\n  go(function*() {\n    while (true) {\n      var part = new Array(n);\n      for (var i = 0; i < n; i++) {\n        var value = yield take(ch);\n        if (value === CLOSED) {\n          if (i > 0) {\n            yield put(out, part.slice(0, i));\n          }\n          out.close();\n          return;\n        }\n        part[i] = value;\n      }\n      yield put(out, part);\n    }\n  });\n  return out;\n}\n\n// For channel identification\nvar genId = (function() {\n  var i = 0;\n  return function() {\n    i ++;\n    return \"\" + i;\n  };\n})();\n\nvar ID_ATTR = \"__csp_channel_id\";\n\n// TODO: Do we need to check with hasOwnProperty?\nfunction len(obj) {\n  var count = 0;\n  for (var p in obj) {\n    count ++;\n  }\n  return count;\n}\n\nfunction chanId(ch) {\n  var id = ch[ID_ATTR];\n  if (id === undefined) {\n    id = ch[ID_ATTR] = genId();\n  }\n  return id;\n}\n\nvar Mult = function(ch) {\n  this.taps = {};\n  this.ch = ch;\n};\n\nvar Tap = function(channel, keepOpen) {\n  this.channel = channel;\n  this.keepOpen = keepOpen;\n};\n\nMult.prototype.muxch = function() {\n  return this.ch;\n};\n\nMult.prototype.tap = function(ch, keepOpen) {\n  var id = chanId(ch);\n  this.taps[id] = new Tap(ch, keepOpen);\n};\n\nMult.prototype.untap = function(ch) {\n  delete this.taps[chanId(ch)];\n};\n\nMult.prototype.untapAll = function() {\n  this.taps = {};\n};\n\nfunction mult(ch) {\n  var m = new Mult(ch);\n  var dchan = chan(1);\n  var dcount;\n  function makeDoneCallback(tap) {\n    return function(stillOpen) {\n      dcount --;\n      if (dcount === 0) {\n        putAsync(dchan, true);\n      }\n      if (!stillOpen) {\n        m.untap(tap.channel);\n      }\n    };\n  }\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var id, t;\n      var taps = m.taps;\n      if (value === CLOSED) {\n        for (id in taps) {\n          t = taps[id];\n          if (!t.keepOpen) {\n            t.channel.close();\n          }\n        }\n        // TODO: Is this necessary?\n        m.untapAll();\n        break;\n      }\n      dcount = len(taps);\n      // XXX: This is because putAsync can actually call back\n      // immediately. Fix that\n      var initDcount = dcount;\n      // Put value on tapping channels...\n      for (id in taps) {\n        t = taps[id];\n        putAsync(t.channel, value, makeDoneCallback(t));\n      }\n      // ... waiting for all puts to complete\n      if (initDcount > 0) {\n        yield take(dchan);\n      }\n    }\n  });\n  return m;\n}\n\nmult.tap = function tap(m, ch, keepOpen) {\n  m.tap(ch, keepOpen);\n  return ch;\n};\n\nmult.untap = function untap(m, ch) {\n  m.untap(ch);\n};\n\nmult.untapAll = function untapAll(m) {\n  m.untapAll();\n};\n\nvar Mix = function(ch) {\n  this.ch = ch;\n  this.stateMap = {};\n  this.change = chan();\n  this.soloMode = mix.MUTE;\n};\n\nMix.prototype._changed = function() {\n  putAsync(this.change, true);\n};\n\nMix.prototype._getAllState = function() {\n  var allState = {};\n  var stateMap = this.stateMap;\n  var solos = [];\n  var mutes = [];\n  var pauses = [];\n  var reads;\n  for (var id in stateMap) {\n    var chanData = stateMap[id];\n    var state = chanData.state;\n    var channel = chanData.channel;\n    if (state[mix.SOLO]) {\n      solos.push(channel);\n    }\n    // TODO\n    if (state[mix.MUTE]) {\n      mutes.push(channel);\n    }\n    if (state[mix.PAUSE]) {\n      pauses.push(channel);\n    }\n  }\n  var i, n;\n  if (this.soloMode === mix.PAUSE && solos.length > 0) {\n    n = solos.length;\n    reads = new Array(n + 1);\n    for (i = 0; i < n; i++) {\n      reads[i] = solos[i];\n    }\n    reads[n] = this.change;\n  } else {\n    reads = [];\n    for (id in stateMap) {\n      chanData = stateMap[id];\n      channel = chanData.channel;\n      if (pauses.indexOf(channel) < 0) {\n        reads.push(channel);\n      }\n    }\n    reads.push(this.change);\n  }\n\n  return {\n    solos: solos,\n    mutes: mutes,\n    reads: reads\n  };\n};\n\nMix.prototype.admix = function(ch) {\n  this.stateMap[chanId(ch)] = {\n    channel: ch,\n    state: {}\n  };\n  this._changed();\n};\n\nMix.prototype.unmix = function(ch) {\n  delete this.stateMap[chanId(ch)];\n  this._changed();\n};\n\nMix.prototype.unmixAll = function() {\n  this.stateMap = {};\n  this._changed();\n};\n\nMix.prototype.toggle = function(updateStateList) {\n  // [[ch1, {}], [ch2, {solo: true}]];\n  var length = updateStateList.length;\n  for (var i = 0; i < length; i++) {\n    var ch = updateStateList[i][0];\n    var id = chanId(ch);\n    var updateState = updateStateList[i][1];\n    var chanData = this.stateMap[id];\n    if (!chanData) {\n      chanData = this.stateMap[id] = {\n        channel: ch,\n        state: {}\n      };\n    }\n    for (var mode in updateState) {\n      chanData.state[mode] = updateState[mode];\n    }\n  }\n  this._changed();\n};\n\nMix.prototype.setSoloMode = function(mode) {\n  if (VALID_SOLO_MODES.indexOf(mode) < 0) {\n    throw new Error(\"Mode must be one of: \", VALID_SOLO_MODES.join(\", \"));\n  }\n  this.soloMode = mode;\n  this._changed();\n};\n\nfunction mix(out) {\n  var m = new Mix(out);\n  go(function*() {\n    var state = m._getAllState();\n    while (true) {\n      var result = yield alts(state.reads);\n      var value = result.value;\n      var channel = result.channel;\n      if (value === CLOSED) {\n        delete m.stateMap[chanId(channel)];\n        state = m._getAllState();\n        continue;\n      }\n      if (channel === m.change) {\n        state = m._getAllState();\n        continue;\n      }\n      var solos = state.solos;\n      if (solos.indexOf(channel) > -1 ||\n          (solos.length === 0 && !(state.mutes.indexOf(channel) > -1))) {\n        var stillOpen = yield put(out, value);\n        if (!stillOpen) {\n          break;\n        }\n      }\n    }\n  });\n  return m;\n}\n\nmix.MUTE = \"mute\";\nmix.PAUSE = \"pause\";\nmix.SOLO = \"solo\";\nvar VALID_SOLO_MODES = [mix.MUTE, mix.PAUSE];\n\nmix.add = function admix(m, ch) {\n  m.admix(ch);\n};\n\nmix.remove = function unmix(m, ch) {\n  m.unmix(ch);\n};\n\nmix.removeAll = function unmixAll(m) {\n  m.unmixAll();\n};\n\nmix.toggle = function toggle(m, updateStateList) {\n  m.toggle(updateStateList);\n};\n\nmix.setSoloMode = function setSoloMode(m, mode) {\n  m.setSoloMode(mode);\n};\n\nfunction constantlyNull() {\n  return null;\n}\n\nvar Pub = function(ch, topicFn, bufferFn) {\n  this.ch = ch;\n  this.topicFn = topicFn;\n  this.bufferFn = bufferFn;\n  this.mults = {};\n};\n\nPub.prototype._ensureMult = function(topic) {\n  var m = this.mults[topic];\n  var bufferFn = this.bufferFn;\n  if (!m) {\n    m = this.mults[topic] = mult(chan(bufferFn(topic)));\n  }\n  return m;\n};\n\nPub.prototype.sub = function(topic, ch, keepOpen) {\n  var m = this._ensureMult(topic);\n  return mult.tap(m, ch, keepOpen);\n};\n\nPub.prototype.unsub = function(topic, ch) {\n  var m = this.mults[topic];\n  if (m) {\n    mult.untap(m, ch);\n  }\n};\n\nPub.prototype.unsubAll = function(topic) {\n  if (topic === undefined) {\n    this.mults = {};\n  } else {\n    delete this.mults[topic];\n  }\n};\n\nfunction pub(ch, topicFn, bufferFn) {\n  bufferFn = bufferFn || constantlyNull;\n  var p = new Pub(ch, topicFn, bufferFn);\n  go(function*() {\n    while (true) {\n      var value = yield take(ch);\n      var mults = p.mults;\n      var topic;\n      if (value === CLOSED) {\n        for (topic in mults) {\n          mults[topic].muxch().close();\n        }\n        break;\n      }\n      // TODO: Somehow ensure/document that this must return a string\n      // (otherwise use proper (hash)maps)\n      topic = topicFn(value);\n      var m = mults[topic];\n      if (m) {\n        var stillOpen = yield put(m.muxch(), value);\n        if (!stillOpen) {\n          delete mults[topic];\n        }\n      }\n    }\n  });\n  return p;\n}\n\npub.sub = function sub(p, topic, ch, keepOpen) {\n  return p.sub(topic, ch, keepOpen);\n};\n\npub.unsub = function unsub(p, topic, ch) {\n  p.unsub(topic, ch);\n};\n\npub.unsubAll = function unsubAll(p, topic) {\n  p.unsubAll(topic);\n};\n\nmodule.exports = {\n  mapFrom: mapFrom,\n  mapInto: mapInto,\n  filterFrom: filterFrom,\n  filterInto: filterInto,\n  removeFrom: removeFrom,\n  removeInto: removeInto,\n  mapcatFrom: mapcatFrom,\n  mapcatInto: mapcatInto,\n\n  pipe: pipe,\n  split: split,\n  reduce: reduce,\n  onto: onto,\n  fromColl: fromColl,\n\n  map: map,\n  merge: merge,\n  into: into,\n  take: takeN,\n  unique: unique,\n  partition: partition,\n  partitionBy: partitionBy,\n\n  mult: mult,\n  mix: mix,\n  pub: pub\n};\n\n\n// Possible \"fluid\" interfaces:\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc],\n//   [into, []]\n// )\n\n// thread(\n//   [fromColl, [1, 2, 3, 4]],\n//   [mapFrom, inc, _],\n//   [into, [], _]\n// )\n\n// wrap()\n//   .fromColl([1, 2, 3, 4])\n//   .mapFrom(inc)\n//   .into([])\n//   .unwrap();\n",
    "\"use strict\";\n\nvar csp = require('./csp.core');\n\nfunction pipelineInternal(n, to, from, close, taskFn) {\n  if (n <= 0) {\n    throw new Error('n must be positive');\n  }\n\n  var jobs = csp.chan(n);\n  var results = csp.chan(n);\n\n  for(var _ = 0; _ < n; _++) {\n    csp.go(function* (taskFn, jobs, results) {\n      while (true) {\n        var job = yield csp.take(jobs);\n\n        if (!taskFn(job)) {\n          results.close();\n          break;\n        }\n      }\n    }, [taskFn, jobs, results]);\n  }\n\n  csp.go(function* (jobs, from, results) {\n    while (true) {\n      var v = yield csp.take(from);\n      if (v === csp.CLOSED) {\n        jobs.close();\n        break;\n      } else {\n        var p = csp.chan(1);\n\n        yield csp.put(jobs, [v, p]);\n        yield csp.put(results, p);\n      }\n    }\n  }, [jobs, from, results]);\n\n  csp.go(function* (results, close, to) {\n    while(true) {\n      var p = yield csp.take(results);\n      if (p === csp.CLOSED) {\n        if (close) {\n          to.close();\n        }\n        break;\n      } else {\n        var res = yield csp.take(p);\n        while(true) {\n          var v = yield csp.take(res);\n          if (v !== csp.CLOSED) {\n            yield csp.put(to, v);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }, [results, close, to]);\n\n  return to;\n}\n\nfunction pipeline(to, xf, from, keepOpen, exHandler) {\n\n  function taskFn(job) {\n    if (job === csp.CLOSED) {\n      return null;\n    } else {\n      var v = job[0];\n      var p = job[1];\n      var res = csp.chan(1, xf, exHandler);\n\n      csp.go(function* (res, v) {\n        yield csp.put(res, v);\n        res.close();\n      }, [res, v]);\n\n      csp.putAsync(p, res);\n\n      return true;\n    }\n  }\n\n  return pipelineInternal(1, to, from, !keepOpen, taskFn);\n}\n\nfunction pipelineAsync(n, to, af, from, keepOpen) {\n\n  function taskFn(job) {\n    if (job === csp.CLOSED) {\n      return null;\n    } else {\n      var v = job[0];\n      var p = job[1];\n      var res = csp.chan(1);\n      af(v, res);\n      csp.putAsync(p, res);\n      return true;\n    }\n  }\n\n  return pipelineInternal(n, to, from, !keepOpen, taskFn);\n}\n\nmodule.exports = {\n  pipeline: pipeline,\n  pipelineAsync: pipelineAsync\n};\n",
    "\"use strict\";\n\n// TODO: Consider EmptyError & FullError to avoid redundant bound\n// checks, to improve performance (may need benchmarks)\n\nfunction acopy(src, src_start, dst, dst_start, length) {\n  var count = 0;\n  while (true) {\n    if (count >= length) {\n      break;\n    }\n    dst[dst_start + count] = src[src_start + count];\n    count ++;\n  }\n}\n\nfunction noop() {};\n\nvar EMPTY = {\n  toString: function() {\n    return \"[object EMPTY]\";\n  }\n};\n\nvar RingBuffer = function(head, tail, length, array) {\n  this.length = length;\n  this.array = array;\n  this.head = head;\n  this.tail = tail;\n};\n\n// Internal method, callers must do bound check\nRingBuffer.prototype._unshift = function(item) {\n  var array = this.array;\n  var head = this.head;\n  array[head] = item;\n  this.head = (head + 1) % array.length;\n  this.length ++;\n};\n\nRingBuffer.prototype._resize = function() {\n  var array = this.array;\n  var new_length = 2 * array.length;\n  var new_array = new Array(new_length);\n  var head = this.head;\n  var tail = this.tail;\n  var length = this.length;\n  if (tail < head) {\n    acopy(array, tail, new_array, 0, length);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail > head) {\n    acopy(array, tail, new_array, 0, array.length - tail);\n    acopy(array, 0, new_array, array.length - tail, head);\n    this.tail = 0;\n    this.head = length;\n    this.array = new_array;\n  } else if (tail === head) {\n    this.tail = 0;\n    this.head = 0;\n    this.array = new_array;\n  }\n};\n\nRingBuffer.prototype.unbounded_unshift = function(item) {\n  if (this.length + 1 === this.array.length) {\n    this._resize();\n  }\n  this._unshift(item);\n};\n\nRingBuffer.prototype.pop = function() {\n  if (this.length === 0) {\n    return EMPTY;\n  }\n  var array = this.array;\n  var tail = this.tail;\n  var item = array[tail];\n  array[tail] = null;\n  this.tail = (tail + 1) % array.length;\n  this.length --;\n  return item;\n};\n\nRingBuffer.prototype.cleanup = function(predicate) {\n  var length = this.length;\n  for (var i = 0; i < length; i++) {\n    var item = this.pop();\n    if (predicate(item)) {\n      this._unshift(item);\n    }\n  }\n};\n\nvar FixedBuffer = function(buf,  n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nFixedBuffer.prototype.is_full = function() {\n  return this.buf.length >= this.n;\n};\n\nFixedBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nFixedBuffer.prototype.add = function(item) {\n  // Note that even though the underlying buffer may grow, \"n\" is\n  // fixed so after overflowing the buffer is still considered full.\n  this.buf.unbounded_unshift(item);\n};\n\nFixedBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\nFixedBuffer.prototype.close = noop;\n\nvar DroppingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nDroppingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nDroppingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nDroppingBuffer.prototype.add = function(item) {\n  if (this.buf.length < this.n) {\n    this.buf._unshift(item);\n  }\n};\n\nDroppingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\nDroppingBuffer.prototype.close = noop;\n\nvar SlidingBuffer = function(buf, n) {\n  this.buf = buf;\n  this.n = n;\n};\n\nSlidingBuffer.prototype.is_full = function() {\n  return false;\n};\n\nSlidingBuffer.prototype.remove = function() {\n  return this.buf.pop();\n};\n\nSlidingBuffer.prototype.add = function(item) {\n  if (this.buf.length === this.n) {\n    this.buf.pop();\n  }\n  this.buf._unshift(item);\n};\n\nSlidingBuffer.prototype.count = function() {\n  return this.buf.length;\n};\n\nSlidingBuffer.prototype.close = noop;\n\nvar PromiseBuffer = function PromiseBuffer() {\n  this.val = EMPTY;\n};\n\nPromiseBuffer.prototype.count = function() {\n  return (this.val === EMPTY) ? 0 : 1;\n};\n\nPromiseBuffer.prototype.add = function(item) {\n  if (this.val === EMPTY) {\n    this.val = item;\n  }\n};\n\nPromiseBuffer.prototype.is_full = function() {\n  return false;\n};\n\nPromiseBuffer.prototype.remove = function() {\n  return this.val;\n};\n\nPromiseBuffer.prototype.close = function() {\n  this.val = EMPTY;\n};\n\nvar ring = exports.ring = function ring_buffer(n) {\n  return new RingBuffer(0, 0, 0, new Array(n));\n};\n\n/**\n * Returns a buffer that is considered \"full\" when it reaches size n,\n * but still accepts additional items, effectively allow overflowing.\n * The overflowing behavior is useful for supporting \"expanding\"\n * transducers, where we want to check if a buffer is full before\n * running the transduced step function, while still allowing a\n * transduced step to expand into multiple \"essence\" steps.\n */\nexports.fixed = function fixed_buffer(n) {\n  return new FixedBuffer(ring(n), n);\n};\n\nexports.dropping = function dropping_buffer(n) {\n  return new DroppingBuffer(ring(n), n);\n};\n\nexports.sliding = function sliding_buffer(n) {\n  return new SlidingBuffer(ring(n), n);\n};\n\nexports.promise = function promise_buffer() {\n  return new PromiseBuffer();\n};\n\nexports.EMPTY = EMPTY;\n",
    "\"use strict\";\n\nvar buffers = require(\"./buffers\");\nvar dispatch = require(\"./dispatch\");\n\nvar MAX_DIRTY = 64;\nvar MAX_QUEUE_SIZE = 1024;\n\nvar CLOSED = null;\n\nvar Box = function(value) {\n  this.value = value;\n};\n\nvar PutBox = function(handler, value) {\n  this.handler = handler;\n  this.value = value;\n};\n\nvar Channel = function(takes, puts, buf, xform) {\n  this.buf = buf;\n  this.xform = xform;\n  this.takes = takes;\n  this.puts = puts;\n\n  this.dirty_takes = 0;\n  this.dirty_puts = 0;\n  this.closed = false;\n};\n\nfunction isReduced(v) {\n  return v && v[\"@@transducer/reduced\"];\n}\n\nfunction schedule(f, v) {\n  dispatch.run(function() {\n    f(v);\n  });\n}\n\nChannel.prototype._put = function(value, handler) {\n  if (value === CLOSED) {\n    throw new Error(\"Cannot put CLOSED on a channel.\");\n  }\n\n  // TODO: I'm not sure how this can happen, because the operations\n  // are registered in 1 tick, and the only way for this to be inactive\n  // is for a previous operation in the same alt to have returned\n  // immediately, which would have short-circuited to prevent this to\n  // be ever register anyway. The same thing goes for the active check\n  // in \"_take\".\n  if (!handler.is_active()) {\n    return null;\n  }\n\n  if (this.closed) {\n    handler.commit();\n    return new Box(false);\n  }\n\n  var taker, callback;\n\n  // Soak the value through the buffer first, even if there is a\n  // pending taker. This way the step function has a chance to act on the\n  // value.\n  if (this.buf && !this.buf.is_full()) {\n    handler.commit();\n    var done = isReduced(this.xform[\"@@transducer/step\"](this.buf, value));\n    while (true) {\n      if (this.buf.count() === 0) {\n        break;\n      }\n      taker = this.takes.pop();\n      if (taker === buffers.EMPTY) {\n        break;\n      }\n      if (taker.is_active()) {\n        value = this.buf.remove();\n        callback = taker.commit();\n        schedule(callback, value);\n      }\n    }\n    if (done) {\n      this.close();\n    }\n    return new Box(true);\n  }\n\n  // Either the buffer is full, in which case there won't be any\n  // pending takes, or we don't have a buffer, in which case this loop\n  // fulfills the first of them that is active (note that we don't\n  // have to worry about transducers here since we require a buffer\n  // for that).\n  while (true) {\n    taker = this.takes.pop();\n    if (taker === buffers.EMPTY) {\n      break;\n    }\n    if (taker.is_active()) {\n      handler.commit();\n      callback = taker.commit();\n      schedule(callback, value);\n      return new Box(true);\n    }\n  }\n\n  // No buffer, full buffer, no pending takes. Queue this put now.\n  if (this.dirty_puts > MAX_DIRTY) {\n    this.puts.cleanup(function(putter) {\n      return putter.handler.is_active();\n    });\n    this.dirty_puts = 0;\n  } else {\n    this.dirty_puts ++;\n  }\n  if (this.puts.length >= MAX_QUEUE_SIZE) {\n    throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending puts are allowed on a single channel.\");\n  }\n  this.puts.unbounded_unshift(new PutBox(handler, value));\n  return null;\n};\n\nChannel.prototype._take = function(handler) {\n  if (!handler.is_active()) {\n    return null;\n  }\n\n  var putter, put_handler, callback, value;\n\n  if (this.buf && this.buf.count() > 0) {\n    handler.commit();\n    value = this.buf.remove();\n    // We need to check pending puts here, other wise they won't\n    // be able to proceed until their number reaches MAX_DIRTY\n    while (true) {\n      if (this.buf.is_full()) {\n        break;\n      }\n      putter = this.puts.pop();\n      if (putter === buffers.EMPTY) {\n        break;\n      }\n      put_handler = putter.handler;\n      if (put_handler.is_active()) {\n        callback = put_handler.commit();\n        if (callback) {\n          schedule(callback, true);\n        }\n        if (isReduced(this.xform[\"@@transducer/step\"](this.buf, putter.value))) {\n          this.close();\n        }\n      }\n    }\n    return new Box(value);\n  }\n\n  // Either the buffer is empty, in which case there won't be any\n  // pending puts, or we don't have a buffer, in which case this loop\n  // fulfills the first of them that is active (note that we don't\n  // have to worry about transducers here since we require a buffer\n  // for that).\n  while (true) {\n    putter = this.puts.pop();\n    value = putter.value;\n    if (putter === buffers.EMPTY) {\n      break;\n    }\n    put_handler = putter.handler;\n    if (put_handler.is_active()) {\n      handler.commit();\n      callback = put_handler.commit();\n      if (callback) {\n        schedule(callback, true);\n      }\n      return new Box(value);\n    }\n  }\n\n  if (this.closed) {\n    handler.commit();\n    return new Box(CLOSED);\n  }\n\n  // No buffer, empty buffer, no pending puts. Queue this take now.\n  if (this.dirty_takes > MAX_DIRTY) {\n    this.takes.cleanup(function(handler) {\n      return handler.is_active();\n    });\n    this.dirty_takes = 0;\n  } else {\n    this.dirty_takes ++;\n  }\n  if (this.takes.length >= MAX_QUEUE_SIZE) {\n    throw new Error(\"No more than \" + MAX_QUEUE_SIZE + \" pending takes are allowed on a single channel.\");\n  }\n  this.takes.unbounded_unshift(handler);\n  return null;\n};\n\nChannel.prototype.close = function() {\n  if (this.closed) {\n    return;\n  }\n  this.closed = true;\n\n  // TODO: Duplicate code. Make a \"_flush\" function or something\n  if (this.buf) {\n    this.buf.close();\n    this.xform[\"@@transducer/result\"](this.buf);\n    while (true) {\n      if (this.buf.count() === 0) {\n        break;\n      }\n      taker = this.takes.pop();\n      if (taker === buffers.EMPTY) {\n        break;\n      }\n      if (taker.is_active()) {\n        callback = taker.commit();\n        var value = this.buf.remove();\n        schedule(callback, value);\n      }\n    }\n  }\n\n  while (true) {\n    var taker = this.takes.pop();\n    if (taker === buffers.EMPTY) {\n      break;\n    }\n    if (taker.is_active()) {\n      var callback = taker.commit();\n      schedule(callback, CLOSED);\n    }\n  }\n\n  while (true) {\n    var putter = this.puts.pop();\n    if (putter === buffers.EMPTY) {\n      break;\n    }\n    if (putter.handler.is_active()) {\n      var put_callback = putter.handler.commit();\n      if (put_callback) {\n        schedule(put_callback, false);\n      }\n    }\n  }\n};\n\n\nChannel.prototype.is_closed = function() {\n  return this.closed;\n};\n\nfunction defaultHandler(e) {\n  console.log('error in channel transformer', e.stack);\n  return CLOSED;\n}\n\nfunction handleEx(buf, exHandler, e) {\n  var def = (exHandler || defaultHandler)(e);\n  if (def !== CLOSED) {\n    buf.add(def);\n  }\n  return buf;\n}\n\n// The base transformer object to use with transducers\nfunction AddTransformer() {\n}\n\nAddTransformer.prototype[\"@@transducer/init\"] = function() {\n  throw new Error('init not available');\n};\n\nAddTransformer.prototype[\"@@transducer/result\"] = function(v) {\n  return v;\n};\n\nAddTransformer.prototype[\"@@transducer/step\"] = function(buffer, input) {\n  buffer.add(input);\n  return buffer;\n};\n\n\nfunction handleException(exHandler) {\n  return function(xform) {\n    return {\n      \"@@transducer/step\": function(buffer, input) {\n        try {\n          return xform[\"@@transducer/step\"](buffer, input);\n        } catch (e) {\n          return handleEx(buffer, exHandler, e);\n        }\n      },\n      \"@@transducer/result\": function(buffer) {\n        try {\n          return xform[\"@@transducer/result\"](buffer);\n        } catch (e) {\n          return handleEx(buffer, exHandler, e);\n        }\n      }\n    };\n  };\n}\n\n// XXX: This is inconsistent. We should either call the reducing\n// function xform, or call the transducer xform, not both\nexports.chan = function(buf, xform, exHandler) {\n  if (xform) {\n    if (!buf) {\n      throw new Error(\"Only buffered channels can use transducers\");\n    }\n\n    xform = xform(new AddTransformer());\n  } else {\n    xform = new AddTransformer();\n  }\n  xform = handleException(exHandler)(xform);\n\n  return new Channel(buffers.ring(32), buffers.ring(32), buf, xform);\n};\n\nexports.Box = Box;\nexports.Channel = Channel;\nexports.CLOSED = CLOSED;\n",
    "\"use strict\";\n\n// TODO: Use process.nextTick if it's available since it's more\n// efficient\n// http://howtonode.org/understanding-process-next-tick\n// Maybe we don't even need to queue ourselves in that case?\n\n// XXX: But http://blog.nodejs.org/2013/03/11/node-v0-10-0-stable/\n// Looks like it will blow up the stack (or is that just about\n// pre-empting IO (but that's already bad enough IMO)?)\n\n// Looks like\n// http://nodejs.org/api/process.html#process_process_nexttick_callback\n// is the equivalent of our TASK_BATCH_SIZE\n\nvar buffers = require(\"./buffers\");\n\nvar TASK_BATCH_SIZE = 1024;\n\nvar tasks = buffers.ring(32);\nvar running = false;\nvar queued = false;\n\nvar queue_dispatcher;\n\nfunction process_messages() {\n  running = true;\n  queued = false;\n  var count = 0;\n  while (true) {\n    var task = tasks.pop();\n    if (task === buffers.EMPTY) {\n      break;\n    }\n    // TODO: Don't we need a try/finally here?\n    task();\n    if (count >= TASK_BATCH_SIZE) {\n      break;\n    }\n    count ++;\n  }\n  running = false;\n  if (tasks.length > 0) {\n    queue_dispatcher();\n  }\n}\n\nif (typeof MessageChannel !== \"undefined\") {\n  var message_channel = new MessageChannel();\n  message_channel.port1.onmessage = function(_) {\n    process_messages();\n  };\n  queue_dispatcher = function()  {\n    if (!(queued && running)) {\n      queued = true;\n      message_channel.port2.postMessage(0);\n    }\n  };\n} else if (typeof setImmediate !== \"undefined\") {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setImmediate(process_messages);\n    }\n  };\n} else {\n  queue_dispatcher = function() {\n    if (!(queued && running)) {\n      queued = true;\n      setTimeout(process_messages, 0);\n    }\n  };\n}\n\nexports.run = function (f) {\n  tasks.unbounded_unshift(f);\n  queue_dispatcher();\n};\n\nexports.queue_delay = function(f, delay) {\n  setTimeout(f, delay);\n};\n",
    "\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar select = require(\"./select\");\nvar Channel = require(\"./channels\").Channel;\n\nvar FnHandler = function(f) {\n  this.f = f;\n};\n\nFnHandler.prototype.is_active = function() {\n  return true;\n};\n\nFnHandler.prototype.commit = function() {\n  return this.f;\n};\n\nfunction put_then_callback(channel, value, callback) {\n  var result = channel._put(value, new FnHandler(callback));\n  if (result && callback) {\n    callback(result.value);\n  }\n}\n\nfunction take_then_callback(channel, callback) {\n  var result = channel._take(new FnHandler(callback));\n  if (result) {\n    callback(result.value);\n  }\n}\n\nvar Process = function(gen, onFinish, creator) {\n  this.gen = gen;\n  this.creatorFunc = creator;\n  this.finished = false;\n  this.onFinish = onFinish;\n};\n\nvar Instruction = function(op, data) {\n  this.op = op;\n  this.data = data;\n};\n\nvar TAKE = \"take\";\nvar PUT = \"put\";\nvar SLEEP = \"sleep\";\nvar ALTS = \"alts\";\n\n// TODO FIX XXX: This is a (probably) temporary hack to avoid blowing\n// up the stack, but it means double queueing when the value is not\n// immediately available\nProcess.prototype._continue = function(response) {\n  var self = this;\n  dispatch.run(function() {\n    self.run(response);\n  });\n};\n\nProcess.prototype._done = function(value) {\n  if (!this.finished) {\n    this.finished = true;\n    var onFinish = this.onFinish;\n    if (typeof onFinish === \"function\") {\n      dispatch.run(function() {\n        onFinish(value);\n      });\n    }\n  }\n};\n\nProcess.prototype.run = function(response) {\n  if (this.finished) {\n    return;\n  }\n\n  // TODO: Shouldn't we (optionally) stop error propagation here (and\n  // signal the error through a channel or something)? Otherwise the\n  // uncaught exception will crash some runtimes (e.g. Node)\n  var iter = this.gen.next(response);\n  if (iter.done) {\n    this._done(iter.value);\n    return;\n  }\n\n  var ins = iter.value;\n  var self = this;\n\n  if (ins instanceof Instruction) {\n    switch (ins.op) {\n    case PUT:\n      var data = ins.data;\n      put_then_callback(data.channel, data.value, function(ok) {\n        self._continue(ok);\n      });\n      break;\n\n    case TAKE:\n      var channel = ins.data;\n      take_then_callback(channel, function(value) {\n        self._continue(value);\n      });\n      break;\n\n    case SLEEP:\n      var msecs = ins.data;\n      dispatch.queue_delay(function() {\n        self.run(null);\n      }, msecs);\n      break;\n\n    case ALTS:\n      select.do_alts(ins.data.operations, function(result) {\n        self._continue(result);\n      }, ins.data.options);\n      break;\n    }\n  }\n  else if(ins instanceof Channel) {\n    var channel = ins;\n    take_then_callback(channel, function(value) {\n      self._continue(value);\n    });\n  }\n  else {\n    this._continue(ins);\n  }\n};\n\nfunction take(channel) {\n  return new Instruction(TAKE, channel);\n}\n\nfunction put(channel, value) {\n  return new Instruction(PUT, {\n    channel: channel,\n    value: value\n  });\n}\n\nfunction sleep(msecs) {\n  return new Instruction(SLEEP, msecs);\n}\n\nfunction alts(operations, options) {\n  return new Instruction(ALTS, {\n    operations: operations,\n    options: options\n  });\n}\n\nexports.put_then_callback = put_then_callback;\nexports.take_then_callback = take_then_callback;\nexports.put = put;\nexports.take = take;\nexports.sleep = sleep;\nexports.alts = alts;\nexports.Instruction = Instruction;\nexports.Process = Process;\n",
    "\"use strict\";\n\nvar Box = require(\"./channels\").Box;\n\nvar AltHandler = function(flag, f) {\n  this.f = f;\n  this.flag = flag;\n};\n\nAltHandler.prototype.is_active = function() {\n  return this.flag.value;\n};\n\nAltHandler.prototype.commit = function() {\n  this.flag.value = false;\n  return this.f;\n};\n\nvar AltResult = function(value, channel) {\n  this.value = value;\n  this.channel = channel;\n};\n\nfunction rand_int(n) {\n  return Math.floor(Math.random() * (n + 1));\n}\n\nfunction random_array(n) {\n  var a = new Array(n);\n  var i;\n  for (i = 0; i < n; i++) {\n    a[i] = 0;\n  }\n  for (i = 1; i < n; i++) {\n    var j = rand_int(i);\n    a[i] = a[j];\n    a[j] = i;\n  }\n  return a;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar DEFAULT = {\n  toString: function() {\n    return \"[object DEFAULT]\";\n  }\n};\n\n// TODO: Accept a priority function or something\nexports.do_alts = function(operations, callback, options) {\n  var length = operations.length;\n  // XXX Hmm\n  if (length === 0) {\n    throw new Error(\"Empty alt list\");\n  }\n\n  var priority = (options && options.priority) ? true : false;\n  if (!priority) {\n    var indexes = random_array(length);\n  }\n\n  var flag = new Box(true);\n\n  for (var i = 0; i < length; i++) {\n    var operation = operations[priority ? i : indexes[i]];\n    var port, result;\n    // XXX Hmm\n    if (operation instanceof Array) {\n      var value = operation[1];\n      port = operation[0];\n      // We wrap this in a function to capture the value of \"port\",\n      // because js' closure captures vars by \"references\", not\n      // values. \"let port\" would have worked, but I don't want to\n      // raise the runtime requirement yet. TODO: So change this when\n      // most runtimes are modern enough.\n      result = port._put(value, (function(port) {\n        return new AltHandler(flag, function(ok) {\n          callback(new AltResult(ok, port));\n        });\n      })(port));\n    } else {\n      port = operation;\n      result = port._take((function(port) {\n        return new AltHandler(flag, function(value) {\n          callback(new AltResult(value, port));\n        });\n      })(port));\n    }\n    // XXX Hmm\n    if (result instanceof Box) {\n      callback(new AltResult(result.value, port));\n      break;\n    }\n  }\n\n  if (!(result instanceof Box)\n      && options\n      && hasOwnProperty.call(options, \"default\")) {\n    if (flag.value) {\n      flag.value = false;\n      callback(new AltResult(options[\"default\"], DEFAULT));\n    }\n  }\n};\n\nexports.DEFAULT = DEFAULT;\n",
    "\"use strict\";\n\nvar dispatch = require(\"./dispatch\");\nvar channels = require(\"./channels\");\n\nexports.timeout = function timeout_channel(msecs) {\n  var chan = channels.chan();\n  dispatch.queue_delay(function() {\n    chan.close();\n  }, msecs);\n  return chan;\n};\n",
    "const csp = require(\"js-csp\");\n\nconst proxify = url => 'http://crossorigin.me/' + url;\nconst unproxify = url => url.replace(/http:\\/\\/crossorigin.me\\//, '');\n\nconst fetch = (url) => {\n  const ch = csp.chan();\n\n  if (!url) { return csp.putAsync(ch, new Error('no url given')); };\n\n  const req = new XMLHttpRequest();\n  req.onload = () => {\n    if (req.status == 200) { csp.putAsync(ch, req.responseXML); }\n    else { csp.putAsync(ch, new Error(req.statusText)); }\n  };\n  req.open(\"GET\", proxify(url), true);\n  req.responseType = \"document\";\n  req.overrideMimeType(\"text/html\");\n  req.send();\n  return ch;\n};\n\nconst yorckTitles = () => csp.go(function*() {\n  const url = \"http://www.yorck.de/mobile/filme\";\n  const page = yield csp.take(fetch(url));\n  const els = page.querySelectorAll('.films a');\n  const movieList = [].slice.call(els).map(_ => _.textContent);\n\n  return movieList;\n});\n\nconst getMovieWithRating = (yorckTitle) => csp.go(function*() {\n  function MovieInfos(title = 'n/a', rating = 'n/a', url = '', ratingsCount = '') {\n    this.title = title;\n    this.rating = rating;\n    this.url = url;\n    this.ratingsCount = ratingsCount;\n  };\n\n  const imdbUrl = \"http://www.imdb.com\";\n  const toSearchUrl = movie => `${imdbUrl}/find?s=tt&q=${encodeURIComponent(movie)}`;\n\n  const getMovieUrl = page => {\n    const a = page.querySelector('.findList .result_text a');\n    if (!a) { return '' };\n    return imdbUrl + a.pathname\n  };\n  const movieInfos = page => {\n    const $ = (page, selector) => page.querySelector(selector) || { textContent: \"n/a\" };\n    const imdbTitle = $(page, '#overview-top .header').textContent;\n    const rating = $(page, '#overview-top .star-box-details strong').textContent;\n    const ratingsCount = $(page, '#overview-top .star-box-details > a').textContent;\n\n    return new MovieInfos(imdbTitle, rating, unproxify(page.URL), ratingsCount);\n  };\n\n  const searchPage = yield csp.take(fetch(toSearchUrl(yorckTitle)));\n  const url = getMovieUrl(searchPage);\n  const moviePage = yield csp.take(fetch(url));\n\n  if (!moviePage) { return new MovieInfos() };\n  return movieInfos(moviePage);\n});\n\nconst showOnPage = (yorckTitle, infoCh) => csp.go(function*() {\n  const moviesEl = document.getElementById(\"movies\");\n  const infos = yield csp.take(infoCh);\n  moviesEl.innerHTML += `${yorckTitle}  ${infos.title} <a href='${infos.url}'>${infos.rating} (${infos.ratingsCount})</a><br>`;\n});\n\ncsp.go(function*() {\n  const isNotSneakPreview = title => !title.startsWith('Sneak');\n\n  (yield csp.take(yorckTitles()))\n    .filter(isNotSneakPreview)\n    .map(t => [t, getMovieWithRating(t)])\n    .forEach(function([title, iCh]){ showOnPage(title, iCh); });\n});\n"
  ]
}